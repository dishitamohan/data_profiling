import google.generativeai as genai
import os
import time
import pandas as pd
from google.api_core.exceptions import ResourceExhausted

# Configure Gemini API (replace with your actual Gemini API key)
genai.configure(api_key="AIzaSyDS33SSxFEBsRsHj_DrFm7R3h2sG8MLPgM")

def suggest_remediation_gemini(flags, max_retries=3, delay=1.5):
    """
    Uses Gemini AI to generate comprehensive remediation actions based on the provided flags.
    Implements rate limiting and retries to avoid excessive API requests.

    Args:
        flags (list): List of validation flags for a transaction.
        max_retries (int): Maximum number of retries in case of rate limits.
        delay (float): Initial delay between retries (exponential backoff).

    Returns:
        str: Remediation suggestions generated by Gemini, or an error message if retries fail.
    """
    prompt = (
        "You are a financial compliance expert. A transaction has been flagged for the following issues: "
        + ", ".join(flags)
        + ". Provide comprehensive remediation actions including adjustments, explanations, and compliance steps."
    )

    model = genai.GenerativeModel('models/gemini-1.5-pro-002')

    for attempt in range(max_retries):
        try:
            response = model.generate_content(prompt)
            time.sleep(delay)  # Add delay to avoid hitting rate limits
            return response.text
        except ResourceExhausted:
            wait_time = delay * (2 ** attempt)  # Exponential backoff (1.5s, 3s, 6s...)
            print(f"Rate limit exceeded. Retrying in {wait_time:.2f} seconds...")
            time.sleep(wait_time)

    return "Error: Exceeded API rate limits. Try again later."

def add_remediation_to_data(data):
    """
    For each transaction (row) in the DataFrame, extract the validation flags from the 'Validation_Report'
    column, then use Gemini to generate remediation actions. Implements batch processing to avoid excessive API requests.

    Args:
        data (pd.DataFrame): DataFrame containing transactions with a 'Validation_Report' column.

    Returns:
        pd.DataFrame: DataFrame with an added column 'Remediation_Advice'.
    """
    data = data.iloc[12:22, :]  # Limit the data subset (optional)

    def get_flags(report):
        if isinstance(report, str):
            try:
                report_dict = eval(report)  # Convert string to dictionary
                return report_dict.get("flags", [])
            except Exception:
                return []
        elif isinstance(report, dict):
            return report.get("flags", [])
        return []

    # Apply the function with rate limiting
    data["Remediation_Advice"] = [
        suggest_remediation_gemini(get_flags(rep)) for rep in data["Validation_Report"]
    ]

    # Save the results
    data.to_csv(r"C:\Users\krith\hackathon\data_profiling\data\remediated_data.csv", index=False)
    return data

if __name__ == "__main__":
    # Load validated transactions
    df = pd.read_csv(r"C:\Users\krith\hackathon\data_profiling\data\validated_transactions.csv")

    # Process the data with rate-limited API calls
    df = add_remediation_to_data(df)

    print("Remediation actions assigned. Sample results:")
    print(df[["Transaction_Amount", "Validation_Report", "Remediation_Advice"]].head())
